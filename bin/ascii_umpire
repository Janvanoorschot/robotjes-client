#!/usr/bin/env python3

import sys
import os
rootdir = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
sys.path.append(rootdir)

import argparse
import asyncio
import functools

import config
import client
import aui

from trace_log import TraceLog


class Timer:
    def __init__(self, timeout, callback, repeat=False):
        self.timeout = timeout
        self.callback = callback
        self.repeat = repeat
        self.task = asyncio.ensure_future(self.job())

    async def job(self):
        await asyncio.sleep(self.timeout)
        await self.callback()
        if self.repeat:
            self.task = asyncio.ensure_future(self.job())

    def cancel(self):
        self.task.cancel()


class UmpireClient:

    def __init__(self, args, umpire_screen):
        if args.trace:
            self.trace = True
        else:
            self.trace = False
        self.umpire_screen = umpire_screen
        self.last_gamestatus_tick = {}

    def registered(self, game_id, game_name):
        self.umpire_screen.game_started(game_id, game_name)

    def player_registered(self, player_id, player_name):
        self.umpire_screen.player_registered(player_id, player_name)

    def player_deregistered(self, player_id, player_name):
        self.umpire_screen.player_deregistered(player_id)

    def started(self):
        pass

    def stopped(self, success):
        pass

    def game_status(self, game_tick, game_status):
        if game_status:
            self.umpire_screen.game_status(game_tick, game_status['status'])
            game_tick = game_status['status']['game_tick']
            for player_id, player in game_status['players'].items():
                robos = player['robos']
                for robo_id, robo in robos.items():
                    if (robo_id not in self.last_gamestatus_tick) or (game_tick > self.last_gamestatus_tick[robo_id]):
                        if self.trace:
                            TraceLog.default_logger().trace('umpire.gamestatus', game_tick, robo['pos'], robo['load'], robo['dir'])
                    self.last_gamestatus_tick[robo_id] = game_tick

    def player_status(self, game_tick, player_status):
        if self.trace:
            self.umpire_screen.player_status(game_tick, player_status)

    def tick(self, tick):
        pass

    def game_tick(self, game_tick):
        pass


async def screen_timer(scrn, umpire, loop):
    if scrn.has_key():
        scrn.close()
        await umpire.stop()
    else:
        scrn.timer()


async def main(args, loop):
    scrn = aui.UmpireDisplay()
    clnt = UmpireClient(args, scrn)
    umpire = client.CLIUmpire(loop, args.url, clnt)
    timer1 = Timer(0.5, umpire.timer, True)
    timer2 = Timer(0.05, functools.partial(screen_timer, scrn, umpire, loop), True)
    try:
        await umpire.run_game(args.umpire, args.name, args.password, args.maze)
    except Exception as e:
        print(f"Exception: {str(e)}")
    timer1.cancel()
    timer2.cancel()


if __name__ == "__main__":
    # get commandline arguments
    parser = argparse.ArgumentParser(description='CommandLineInterface (CLI) for Umpire')
    parser.add_argument('--url', type=str, default=config.REST_URL, help='url of the robotjes REST entrypoint')
    parser.add_argument('--umpire', type=str, default="me", help='name or id of the umpire')
    parser.add_argument('--name', type=str, default="game1", help='name of the game to create')
    parser.add_argument('--password', type=str, default="secret1", help='password needed to enter the game')
    parser.add_argument('--maze', type=str, default="default", help='name of the maze to use')
    parser.add_argument('--trace', default=False, action="store_true", help='name of the maze to use')
    args = parser.parse_args()

    # run our main loop
    try:
        aloop = asyncio.get_event_loop()
        aloop.run_until_complete(main(args, aloop))
    except:
        pass
    finally:
        aloop.stop()
